<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="kr.ac.kopo.dao.MemberDAO">

	<!-- 회원 등록 -->
	<insert id="insertMember"
		parameterType="kr.ac.kopo.vo.MemberVO">
		INSERT INTO MEMBER (
		ID, PASSWORD, NICKNAME, EMAIL
		) VALUES (
		#{id}, #{password},
		#{nickname}, #{email}
		)
	</insert>

	<!-- 로그인 -->
	<select id="login" parameterType="kr.ac.kopo.vo.MemberVO"
		resultType="kr.ac.kopo.vo.MemberVO">
		SELECT *
		FROM MEMBER
		WHERE ID = #{id}
		AND PASSWORD =
		#{password}
	</select>

	<!-- 아이디로 회원 정보 조회 (모든 정보) -->
	<select id="selectMemberById"
		resultType="kr.ac.kopo.vo.MemberVO" parameterType="string">
		SELECT * FROM MEMBER WHERE ID = #{id}
	</select>

	<!-- 비밀번호 변경 -->
	<update id="updatePassword">
	    UPDATE MEMBER SET PASSWORD = #{newPassword}
	    WHERE ID = #{id}
	</update>

	<!-- 계정 삭제 -->
	<update id="deleteAccount">
	    UPDATE MEMBER SET STATUS = 'N' WHERE ID = #{id}
	</update>

	<!-- 프로필(닉네임, 이메일) 수정 -->
    <update id="updateProfile" parameterType="kr.ac.kopo.vo.MemberVO">
        UPDATE MEMBER
           SET NICKNAME = #{nickname},
               EMAIL = #{email}
         WHERE ID = #{id}
    </update>

    <!-- ▼▼▼▼▼ [수정] 관리자용: 회원 목록 조회 (페이지네이션 적용) ▼▼▼▼▼ -->
    <select id="selectUserList" parameterType="map" resultType="kr.ac.kopo.vo.MemberVO">
        SELECT 
            ID, 
            NICKNAME, 
            EMAIL, 
            REGDATE, 
            STATUS, 
            TYPE
        FROM MEMBER
        <where>
            <if test="status != null and !status.equals('all')">
                AND STATUS = #{status}
            </if>
            <if test="keyword != null and !keyword.equals('')">
                AND (
                       UPPER(ID) LIKE '%' || UPPER(#{keyword}) || '%'
                    OR UPPER(NICKNAME) LIKE '%' || UPPER(#{keyword}) || '%'
                )
            </if>
        </where>
        ORDER BY TYPE ASC, REGDATE DESC
        OFFSET #{offset} ROWS FETCH NEXT #{limit} ROWS ONLY
    </select>
    
    <!-- ▼▼▼▼▼ [추가] 관리자용: 회원 수 조회 (페이지네이션용) ▼▼▼▼▼ -->
    <select id="selectUserCount" parameterType="map" resultType="int">
        SELECT COUNT(*)
        FROM MEMBER
        <where>
            <if test="status != null and !status.equals('all')">
                AND STATUS = #{status}
            </if>
            <if test="keyword != null and !keyword.equals('')">
                AND (
                       UPPER(ID) LIKE '%' || UPPER(#{keyword}) || '%'
                    OR UPPER(NICKNAME) LIKE '%' || UPPER(#{keyword}) || '%'
                )
            </if>
        </where>
    </select>
    <!-- ▲▲▲▲▲ 여기까지 수정/추가 ▲▲▲▲▲ -->

    <!-- ▼▼▼▼▼ [추가] 관리자용: 회원 상태 변경 ▼▼▼▼▼ -->
    <update id="updateUserStatus" parameterType="map">
        UPDATE MEMBER
           SET STATUS = #{status}
         WHERE ID = #{id}
    </update>
    <!-- ▲▲▲▲▲ 여기까지 추가 ▲▲▲▲▲ -->
    
    <!-- 전체 회원 수 조회 -->
    <select id="getTotalUserCount" resultType="int">
        SELECT COUNT(*)
        FROM MEMBER
    </select>

    <!-- 상태별 회원 수 조회 -->
    <select id="getUserCountByStatus" parameterType="string" resultType="int">
        SELECT COUNT(*)
        FROM MEMBER
        WHERE STATUS = #{status}
    </select>
    
    <!-- 기간별 신규 가입자 수 조회 (0명인 날짜 포함) -->
    <select id="getNewUserCountByPeriod" parameterType="string" resultType="map">
        <choose>
            <when test='period == "daily"'>
                WITH calendar AS (
                    SELECT TRUNC(SYSDATE) - (LEVEL - 1) AS dt
                    FROM DUAL
                    CONNECT BY LEVEL &lt;= 14
                )
                SELECT
                    TO_CHAR(c.dt, 'YYYY-MM-DD') AS "period",
                    COUNT(m.ID) AS "count"
                FROM calendar c
                LEFT JOIN MEMBER m ON TRUNC(m.REGDATE) = c.dt
                GROUP BY c.dt
                ORDER BY c.dt ASC
            </when>
            <when test='period == "weekly"'>
                WITH calendar AS (
                    SELECT TRUNC(SYSDATE, 'IW') - ((LEVEL - 1) * 7) AS start_of_week
                    FROM DUAL
                    CONNECT BY LEVEL &lt;= 8
                )
                SELECT
                    TO_CHAR(c.start_of_week, 'YYYY-MM-DD') AS "period",
                    COUNT(m.ID) AS "count"
                FROM calendar c
                LEFT JOIN MEMBER m ON TRUNC(m.REGDATE, 'IW') = c.start_of_week
                GROUP BY c.start_of_week
                ORDER BY c.start_of_week ASC
            </when>
            <when test='period == "monthly"'>
                WITH calendar AS (
                    SELECT ADD_MONTHS(TRUNC(SYSDATE, 'MM'), -(LEVEL - 1)) AS start_of_month
                    FROM DUAL
                    CONNECT BY LEVEL &lt;= 6
                )
                SELECT
                    TO_CHAR(c.start_of_month, 'YYYY-MM-DD') AS "period",
                    COUNT(m.ID) AS "count"
                FROM calendar c
                LEFT JOIN MEMBER m ON TRUNC(m.REGDATE, 'MM') = c.start_of_month
                GROUP BY c.start_of_month
                ORDER BY c.start_of_month ASC
            </when>
        </choose>
    </select>
    
    <!-- 리뷰 작성 순위 상위 10명 조회 -->
    <select id="getUsersRankedByReviewCount" resultType="kr.ac.kopo.vo.MemberVO">
        SELECT
            m.ID,
            m.NICKNAME,
            m.REGDATE,
            m.STATUS,
            COUNT(r.REVIEW_ID) AS reviewCount
        FROM MEMBER m
        JOIN RESTAURANT_REVIEW r ON m.ID = r.MEMBER_ID
        GROUP BY m.ID, m.NICKNAME, m.REGDATE, m.STATUS
        ORDER BY reviewCount DESC
        FETCH FIRST 10 ROWS ONLY
    </select>

    <!-- 찜 등록 순위 상위 10명 조회 -->
    <select id="getUsersRankedByFavoriteCount" resultType="kr.ac.kopo.vo.MemberVO">
        SELECT
            m.ID,
            m.NICKNAME,
            m.REGDATE,
            m.STATUS,
            COUNT(f.MEMBER_ID) AS favoriteCount
        FROM MEMBER m
        JOIN FAVORITE_RESTAURANT f ON m.ID = f.MEMBER_ID
        GROUP BY m.ID, m.NICKNAME, m.REGDATE, m.STATUS
        ORDER BY favoriteCount DESC
        FETCH FIRST 10 ROWS ONLY
    </select>
</mapper>
